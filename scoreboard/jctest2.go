package scoreboard

import (
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	//"github.com/backend/caldera"
	"github.com/backend/database"
	"github.com/backend/utils"

	_ "github.com/mattn/go-sqlite3"
)

type AutoGenerated struct {
	Chain []struct {
		Finish            time.Time `json:"finish"`
		Decide            time.Time `json:"decide"`
		Paw               string    `json:"paw"`
		Score             int       `json:"score"`
		PlaintextCommand  string    `json:"plaintext_command"`
		AgentReportedTime time.Time `json:"agent_reported_time"`
		Cleanup           int       `json:"cleanup"`
		Output            string    `json:"output"`
		Host              string    `json:"host"`
		Unique            string    `json:"unique"`
		Status            int       `json:"status"`
		Ability           struct {
			AdditionalInfo struct {
				Cleanup string `json:"cleanup"`
			} `json:"additional_info"`
			Executors []struct {
				Code           interface{} `json:"code"`
				AdditionalInfo struct {
				} `json:"additional_info"`
				Payloads    []interface{} `json:"payloads"`
				Command     string        `json:"command"`
				Name        string        `json:"name"`
				Language    interface{}   `json:"language"`
				Timeout     int           `json:"timeout"`
				Cleanup     []interface{} `json:"cleanup"`
				Uploads     []interface{} `json:"uploads"`
				Parsers     []interface{} `json:"parsers"`
				Platform    string        `json:"platform"`
				BuildTarget interface{}   `json:"build_target"`
				Variations  []interface{} `json:"variations"`
			} `json:"executors"`
			Name          string        `json:"name"`
			Buckets       []interface{} `json:"buckets"`
			TechniqueID   string        `json:"technique_id"`
			TechniqueName string        `json:"technique_name"`
			AbilityID     string        `json:"ability_id"`
			DeletePayload bool          `json:"delete_payload"`
			Singleton     bool          `json:"singleton"`
			Tactic        string        `json:"tactic"`
			Description   string        `json:"description"`
			Requirements  []interface{} `json:"requirements"`
			Privilege     string        `json:"privilege"`
			Plugin        string        `json:"plugin"`
			Access        struct {
			} `json:"access"`
			Repeatable bool `json:"repeatable"`
		} `json:"ability"`
		Relationships []interface{} `json:"relationships"`
		Facts         []interface{} `json:"facts"`
		Pin           int           `json:"pin"`
		Deadman       bool          `json:"deadman"`
		Executor      struct {
			Code           interface{} `json:"code"`
			AdditionalInfo struct {
			} `json:"additional_info"`
			Payloads    []interface{} `json:"payloads"`
			Command     string        `json:"command"`
			Name        string        `json:"name"`
			Language    interface{}   `json:"language"`
			Timeout     int           `json:"timeout"`
			Cleanup     []interface{} `json:"cleanup"`
			Uploads     []interface{} `json:"uploads"`
			Parsers     []interface{} `json:"parsers"`
			Platform    string        `json:"platform"`
			BuildTarget interface{}   `json:"build_target"`
			Variations  []interface{} `json:"variations"`
		} `json:"executor"`
		Command    string `json:"command"`
		Visibility struct {
			Adjustments []interface{} `json:"adjustments"`
			Score       int           `json:"score"`
		} `json:"visibility"`
		ID      string        `json:"id"`
		Pid     string        `json:"pid"`
		Used    []interface{} `json:"used"`
		Collect time.Time     `json:"collect"`
	} `json:"chain"`
}

func Cal(Get_id string) int {
	db := database.DB()

	userid := Get_id

	scoreMap := map[string]int{}

	// query2 := "select solved_scenario_id from solved_scenario where user_id = '" + userid + "'"
	solvedSceRows, err := db.Query("select solved_scenario_id from solved_scenario where user_id=?", userid)
	utils.HandleError(err)
	defer solvedSceRows.Close()

	for solvedSceRows.Next() {
		var scenarioId string
		err := solvedSceRows.Scan(&scenarioId)
		utils.HandleError(err)

		var operationId string
		// query := "select operation_id from solved_scenario where user_id = '" + userid + "' and solved_scenario_id = " + sce_id
		row := db.QueryRow("select operation_id from solved_scenario where user_id=? and solved_scenario_id=?", userid, scenarioId)
		err = row.Scan(&operationId)
		utils.HandleError(err)

		url := "http://pdxf.tk:8888/api/v2/operations/" + operationId + "?include=chain"
		req, err := http.NewRequest("GET", url, nil)
		utils.HandleError(err)

		req.Header.Add("KEY", "ADMIN123")

		client := &http.Client{}
		res, err := client.Do(req)
		utils.HandleError(err)
		defer res.Body.Close()

		result := AutoGenerated{}
		json.NewDecoder(res.Body).Decode(&result)

		var stopFlag int
		var cal_payload string
		for i, v := range result.Chain {
			if v.Status == 1 {
				cal_payload = v.Executor.Command
				stopFlag = i
				break
			}
		}

		var sce_score float32
		// query3 := "select id from challenge where scenario_id = '" + sce_id + "'"
		row3, err := db.Query("select id from challenge where scenario_id = ?", scenarioId)
		utils.HandleError(err)
		defer row3.Close()

		for row3.Next() {
			var ch_id string
			row3.Scan(&ch_id)

			// query4 := "select id from tactic where challenge_id = '" + ch_id + "'"
			row4, err := db.Query("select id from tactic where challenge_id = ?", ch_id)
			utils.HandleError(err)
			defer row4.Close()

			for row4.Next() {
				var tactic_id string
				err = row4.Scan(&tactic_id)
				utils.HandleError(err)

				var dbpayload string
				// query5 := "select payload from payload where tactic_id = '" + tactic_id + "'"
				row5 := db.QueryRow("select payload from payload where tactic_id = ?", tactic_id)
				err = row5.Scan(&dbpayload)
				utils.HandleError(err)

				if cal_payload != dbpayload {
					continue
				}
				var ch_score float32
				// query6 := "select score from challenge where id = '" + ch_id + "'"
				row6 := db.QueryRow("select score from challenge where id = ?", ch_id)
				err = row6.Scan(&ch_score)
				utils.HandleError(err)

				sce_per := ((float32(len(result.Chain)) - float32(stopFlag)) / float32(len(result.Chain)))
				sce_score = float32(ch_score) * sce_per

				// crows, err := db.Query("select score from solved_ir_score where user_id=? and sce_id=?", userid, scenarioId)
				// utils.HandleError(err)

				// if crows.Next() {
				// 	// _, err = db.Exec("update solved_ir_score set score = 1 where user_id=? and sce_id=?", userid, scenarioId)
				// 	// utils.HandleError(err)
				// 	} else {
				// 		_, err = db.Exec("insert into solved_ir_score values ('1', '1', 1)")
				// 		utils.HandleError(err)
				// 	}
				scoreMap[scenarioId] = int(sce_score)

				fmt.Println(sce_score)
			}
			row4.Close()
		}
		row3.Close()

	}
	solvedSceRows.Close()
	fmt.Println(scoreMap)

	for sceid, v := range scoreMap {
		var check_db string
		fmt.Println(userid, sceid)
		row7 := db.QueryRow("select exists(select * from solved_ir_score where user_id='pdxf' and sce_id='32')")
		row7.Scan(&check_db)
		utils.HandleError(err)
		fmt.Println(check_db)
		if check_db == "1" {
			db.Exec("update solved_ir_score set score=? where user_id=? and sce_id=?", v, userid, sceid)
		}
		if check_db == "0" {
			db.Exec("insert into solved_ir_score values (?, ?, ?)", userid, sceid, v)
		}
	}
	return 0
}
